# **华东师范大学数据科学与工程学院上机实践报告**

***

课程名称：算法设计与分析      

上机实验名称：np问题  

编号：No.14

年级：21级        

日期：2022年6月7号

***

## 1.实验目的

- 本实验主要解决以下问题：
  - TSP问题（旅行商问题）

## 2. 算法思路

### 旅行商问题

- 旅行商问题（TSP）是一种典型的NP-Hard问题，简单描述就是图中从起点走一圈回到起点的**最短路径**，也可以理解成组合优化问题，这个问题到现代有非常非常多的解法，比如上课讲的*MST近似算法*，本报告用的*动态规划法*，贪心法，邻近法，最简单的暴力法O(n!)，以及现代算法当中的很多方法，退火算法，遗传算法，各种启发和亚启发式算法，基于数学和计算机理论都有了新的发展。本质上这些算法都是为了在NP时间内尽可能地降低算法时间和空间复杂度的上下界，以及期望值。
- 由于个人的能力限制，以及时间上的限制，这次的报告只分析**优化过的动归算法**的实现，时间复杂度的简要推导，严谨的数学推导需要系统的数学和算法分析知识，可以看看其他的一些分析

https://zhuanlan.zhihu.com/p/467270686 TSP求解算法合集

https://zhuanlan.zhihu.com/p/102709464 TSP的启发式算法



### 算法思路

- 没有优化过的动态规划解法的思路非常简单，概括一下就是**决策倒推**

- 第一步

首先既然是决策倒推，就是从最后到终点往前面推，假设终点是m0，我们有剩下三个节点m1, m2, m3, 那么我们需要的路径无非三种情况，记dp为已经决策过的函数，c是距离函数，那么

dp[final m0(from m1, m2, m3)] 

= min(c1->0 + dp(m1(from m2, m3)),  c2->0 + dp(m2(from m1, m3)),  c3->0 + dp(m3(from m2, m1)))

简单来说，就是三种决策加上现在的路径取得的**最小值**是我们要的**总体的最小值**

- 第二步

有了这样的思路其实就非常容易了，分别求出上部决策中三个dp的值，举个例子

dp(m1(from m2, m3)) = min( dp(m2(from m3)) + c2->1, dp(m3(from m2)) + c3->1)

这样我们一直迭代这一步，直到dp函数只有一种取法，也就是例如只剩下dp(m1 from empty) = c0->1，迭代终止

这里的**状态转移方程**就不写了，那个非常地不好看而且不好理解，本质上就是第二步的实现，这个过程就是状态转移方程

- 第三步

我们实际设计程序的时候是反过来的，我们不可能知道第一步中哪一个是最小，所以每一个都要求

- 时间复杂度问题

其实有一种非常快速的分析法，就是一个点**在不在**这个最短路径集合，只有两种情况，true和false，每次遍历的时候每个点都需要判断，**每个点都需要和前序的点进行状态转移方程判断**，一共遍历的此时就有2^n种，遍历的次数可以按照上面的规律，每k个节点需要这样操作k-1次，以此递推，那么我们就可以得到一个算法的上界，也就是$ O(n^{2}2^{n})$

如果不用这个**在不在**方法分析的话求的式子就更加精确，不过结果还是一样的
$$
\sum k(k-1)C_{n-1}^{k}+O(n) = O(n^{2}2^{n})
$$
结果是一样的，O(n)指的是正向的第一步，组合数就是动态规划实现的过程

- 算法的优化放在代码之后讲，因为不影响时间复杂度的上界，所以这里不写防止干扰



## 3. 算法实现

完整的代码会在总结之后给出

```cpp
void solve(){
    	// graph是n*n的邻接矩阵，dp是n*2n-1的动态规划数组
        for(int i = 0; i < size(); i++){
            dp[i][0] = graph[i][0];// 前面提到的正向的第一步，也可以说是初始化
        }
		
        // 这里的ij颠倒，就是因为前面提到的，正向的实现和反向的原理的区别
    	// 也就是dp迭代那一步（第二步），dp获得的结果是反向的
        for(int i = 1; i < (1 << (size() - 1)); i++){
            for(int j = 0; j < size(); j++){
                dp[j][i] = INF;
                //node j not visited
                //剪枝优化，访问过的肯定不需要了
                if( ((i >> (j - 1)) & 1) == 0){
                    for(int k = 1; k < size(); k++){
                        // k in i set，也就是前面提到的*在不在*
                        if(((i >> (k - 1)) & 1) != 0){
                            if(dp[j][i] > graph[j][k] + dp[k][i ^ (1 << (k-1))]){
                                dp[j][i] = graph[j][k] + dp[k][i ^ (1 << (k-1))];// 状态转移
                            }
                        }
                    }
                }
            }
        }

        solution = dp[0][(1 << (size()-1)) - 1];// 通过dp迭代最后获得解
    }
```

- 动态规划实现TSP有非常多的优化方案，会对时间和空间造成影响，这里实现了一种，也就是记录节点有没有访问过，也可以引入visited数组进行实现，这里用的是位运算的实现法
- 因为np问题单步的操作会影响很大，所以试着用位运算的方式来加快一些运算，是因为这道题目具有2^n的性质，所以这样算会比较方便快捷，可以具体来看一下
- (i >> (j - 1)) & 1表示的是看第j位是不是1，效果和i & (1 << j)是一样的，好处就是**没有溢出风险**。j是下一步需要访问的节点，i是状态，意思就是访问过的城市集合，**如果i包含了j，那就把j剪枝**，下面的k也是一样的，确保**是由上一步转移来的**这样就不需要开辟新的数组来记录访问节点了，这一步的优化是比较明显的，根据累加公式，可以把式子当中的n直接/2，不过表达式还是一样的
- 状态转移方程中的^是单纯的算法加速，换成-也是一样的，实现的都是前面分析的第二步中剔除i这个元素，因为有前面一定在集合的限制，所以高位不会受到影响



## 4. 总结

- 本次实验实现了动态规划法解决TSP问题，并且使用了剪枝优化的策略，分析了时间复杂度
- 由于dp数组的存在，这次没有使用单向图和单向边的对象和oop的编程思路，要引入也是可以的，只是这个问题比较特殊，只要重新记录Graph这个数据结构就可以了，简单来说只实现了解题的函数
- 位运算在本次实验中可以用常规的乘方和减法代替，不会对时间复杂度造成影响，只会对单步O1的系数造成影响，但是有些算法中，位运算的引入会直接改变时间复杂度，还是值得关注的
- TSP还有非常多的解法，光动归这个方法就有很多的优化策略，以及时间和空间的权衡。许多其他算法都有现代算法的启发式思想。作为最后一次实验报告，我想这些算法也许现在完全看不懂，但是随着理论知识的成型，日后也是非常值得学习和参考的，包括位运算本身对于算法的优化，也是非常值得花时间去学习的，学算法的本质，就是既要理论快也要实际快，对复杂度和实际时间的极致优化永远都是算法这门课最终的目标。

​	

## 5.源码

main.cpp

```cpp
#include<iostream>
#include<vector>

using namespace std;

class TSP{
public:
    typedef vector<vector<int>> Graph;
    static const int INF = INT32_MAX;
    static const int NIL = 0;
private:
    Graph graph;
    vector<vector<int>> dp;
    size_t _size;
    int solution;

public:
    TSP() = default;
    TSP(size_t size1, istream& in){
        _size = size1;

        for(int i = 0; i < _size; i++){
            vector<int> edges;
            vector<int> nullvec(1 << (_size - 1));
            for(int j = 0; j < _size; j++){
                int temp;
                in>>temp;
                edges.push_back(temp);
            }
            graph.push_back(edges);
            dp.push_back(nullvec);
        }

    }

    size_t size() const{
        return _size;
    }

    void solve(){
        for(int i = 0; i < size(); i++){
            dp[i][0] = graph[i][0];
        }

        for(int i = 1; i < (1 << (size() - 1)); i++){
            for(int j = 0; j < size(); j++){
                dp[j][i] = INF;
                //node j not visited
                if( ((i >> (j - 1)) & 1) == 0){
                    for(int k = 1; k < size(); k++){
                        // k in j set
                        if(((i >> (k - 1)) & 1) != 0){
                            if(dp[j][i] > graph[j][k] + dp[k][i ^ (1 << (k-1))]){
                                dp[j][i] = graph[j][k] + dp[k][i ^ (1 << (k-1))];
                            }
                        }
                    }
                }
            }
        }

        solution = dp[0][(1 << (size()-1)) - 1];
    }

    int result() const{
        return solution;
    }
};

int main(){
    int n;
    cin>>n;
    TSP tsp(n, cin);
    tsp.solve();
    cout<<tsp.result()<<endl;
}
```


















​	  



















​    

