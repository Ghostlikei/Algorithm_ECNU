# **华东师范大学数据科学与工程学院上机实践报告**

***

课程名称：算法设计与分析      

上机实验名称：矩阵乘法     

编号：No.02

年级：21级        

日期：2022年3月4号

***

## 1.实验目的

- 本实验主要设计以下两种算法：
  - 朴素矩阵乘法
  - Strassen矩阵乘法

- 分析和比较两种算法的实现原理，算法复杂度，算法时间消耗
- 分析两种算法的实用性，以及优化方案

本实验所有源码（算法源码，构图源码）已上传至个人Github：

https://github.com/Ghostlikei/Algorithm_ECNU/tree/master/Assignment2

## 2. 算法思路

### 2.1 朴素矩阵乘法

- 算法原理

​	  算法原理既普通的矩阵乘法的原理：
$$
c_{ij} = \Sigma a_{ik}b_{kj}
$$

- 算法源码：

```cpp
vector<vector<int>> Multiply(vector<vector<int>> mat1, vector<vector<int>> mat2, int Size){
    vector<vector<int>> result;
    for(int i = 0; i < Size; i++){
        vector<int> vec;
        for(int j = 0; j < Size; j++){
            int sum = 0;
            for(int k = 0; k < Size; k++){
                sum += mat1[i][k]*mat2[k][j];
            }
            vec.push_back(sum);
        }
        result.push_back(vec);
    }
    return result;
}
```

这里由于题目要求比较简单，所以为了方便运算，把矩阵大小统一成n*n，若是一般矩阵只需要把行数和列数分开即可

- 时间复杂度：

  观察可知该算法需要三次循环，而且循环次数固定，所以时间复杂度为**O(n^3)**

- 空间复杂度：

​	  算法只需要一个结果矩阵，所以空间复杂度为**O(n^2)**



### 2.2 Strassen矩阵乘法:

- 算法原理：

​	  关于算法的过程不再赘述，主要关注Strassen如何实现少一次乘法，毕竟乘法在计算机内的耗时相对于加法要大得多

​	  我们先来观察这样一个小学生都会的公式：

**乘法分配律**
$$
a*(b+c) = a*b + a*c
$$
​      当我们用计算机的眼光**从右往左**看待这个公式的时候，会发现这个神奇的公式把**两次乘法和一个加法**用**一个乘法和一个加法**来代替
$$
(a + b) * (c + d)=ac+ad+bc+bd
$$
​	  当左边乘号两边为多个数的时候，**多个乘号**可以用**一个乘号和加法**来代替，这就是类Strassen算法能够剩下时间的核心原因，课上提到的用三次乘法来实现复数相乘的原因也是在此，（据说Strassen本人正是受到了复数算法的启发而想到了这个算法）

​	  当然，由此看来这个算法在乘法分配律公式的基础上还需要补项来让原式成立，这样一来就需要许多**临时变量**和**大量的加法运算**，这也是Strassen算法的缺陷所在，当然在数学的眼光里这个算法优化了复杂度，但是在计算机眼中多了很多相比朴素算法多余的运算，传值的过程也会有相当大的时间消耗。

*算法过程详见算法导论*

- 由于代码过于长，算法源码请见Github

- **时间复杂度**

​	  Strassen算法是把需要计算的目标矩阵全部四等分，之后通过上述的乘法分配律以及补项节省乘法的次数，我们可以得到如下的递推公式：
$$
T(n) = 8*T(\frac{n}{2}) + O(n^2)
$$
通过计算可得，Strassen算法的时间复杂度为**O(n^2.81)**

- **空间复杂度**

​	  空间复杂度也是O(n^2)，但是使用了大量的临时矩阵，所以会导致系数较大，讨论两算法的空间复杂度意义不大

## 3.算法比较

- 由于oj上需要用iostream处理输入和输出（io太慢），以及矩阵的大小，个数不同，同时测试用例太少，所以不用oj的测试用例进行算法的时间比较
- 用python同样实现了两种算法，使用了matplotlib对于两种算法的时间在数据规模从1~500之间绘制了图表进行比较：

![img01.png](https://github.com/Ghostlikei/Algorithm_ECNU/blob/master/Assignment2/img01.png?raw=true)

![img02.png](https://github.com/Ghostlikei/Algorithm_ECNU/blob/master/Assignment2/img02.png?raw=true)

​      由此看来，当矩阵的规模逐渐变大的时候，Strassen具有明显的优势，而矩阵规模较小的时候则是朴素算法更有优势

![img03.png](https://github.com/Ghostlikei/Algorithm_ECNU/blob/master/Assignment2/img03.png?raw=true)

​      其实在绘图的时候本来是想加入numpy自带的算法`np.dot()`进行比较，但是在数据规模很小的时候自带的算法时间几乎为0，优势太过于明显，所以引发了一个问题，dot函数采用了numpy自带的矩阵优化，同时采用了c语言进行编写，效率极高，所以硬件优化和代码优化是不是和算法优化同样重要？

​	  毕竟Strassen虽然时间复杂度较小，但是要大量传值和加法运算，在python这种动态变量语言当中，哪怕使用了numpy的静态变量数组，但是函数调用和传值的过程是非常耗时间的，对于c++和其他语言也是如此。

​	  在访问数组/容器的过程中也会有问题，就拿矩阵乘法来看，横向遍历二维数组是很快的，但在矩阵的乘法公式中需要用到纵向的数组遍历，两者的差距有一个数量级，所以有没有可能在数组本身的结构上进行优化，也能大量减少时间

​	  其实也可以尝试通过对于矩阵性质的判断（大小，形状）等对矩阵乘法进一步优化，例如在小规模的时候使用朴素乘法，大一点的时候进行分治，更大的时候把矩阵切成更多块，进一步分治优化。

## 4.代码编写思路

- 两种算法的代码难度都不高，Strassen算法需要注意不要写错矩阵即可，但是有一些点还是值得讨论的

- 本次我全部采用了**STL**当中的**Vector**容器进行二维数组的存储和运算，原因有以下几点：

  - STL自带优化，容器访问，更改等操作都是包装和优化过的，相对用时较少，调用也比较简单
  - Vector是动态数组，初始化和更改相比于直接用二维数组会简单很多，例如不需要循环重置数组，大大减少代码量
  - Vector自带回收机制，不需要考虑内存的释放问题，减少代码量同时减少运行的时间

  当然在绝对速度上，还是不及二维的静态数组，但是总体上个人还是更加喜欢

## 5.总结

- 本次实验主要手写的矩阵朴素算法和Strassen算法，而个人认为Strassen算法的代码过于冗长了，而且不具有明显优势，在实际编写的过程碰到了比较多的麻烦。
- 上机实验中处理io的过程使用了很多时间，所以从结果上来看两种算法并没有很明显的区别，在数据大的时候Strassen略快一些，但是数据小的时候Strassen所用的时间和数据大的时候相差不大，但是此时朴素算法具有明显的优势
- 本次实验并没有考虑非方形矩阵的情况，由于Strassen代码量过于大，所以重写函数非常不方便（懒得写），就直接默认是n*n的矩阵，放弃了别的形状情况下两算法的区别，实际上若是画出时间图也会比较有意思。


















​	  



















​    

